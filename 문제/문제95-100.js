// *************************************************************
// 문제96 : 넓은 텃밭 만들기!

// 수연이는 밭농사를 시작하기로 마음을 먹었다. 집 앞 텃밭을 만들기로 하고 돌들을 제거하고 있는데 매우 큰 바위는 옮기지 못해 고심하고 있다.

// 이에 수연이는 다음과 같은 규칙을 정한다.

// 1. 바위를(바위는 '1'로 표기한다.) 피해 텃밭을 만들되 정사각형 모양으로 텃밭을 만든다.
// 2. 텃밭은 가장 넓은 텃밭 1개만 만들고 그 크기를 반환한다.
// 3. 만든 텃밭은 모두 '#'으로 처리한다.

let 텃밭 = `0 0 0 0 0
0 1 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0`
  .replace(/1/g, '!')
  .replace(/0/g, '1')
  .replace(/!/g, '0');

// 0과 1을 역전

let 역전된텃밭 = [];

for (let row of 텃밭.split('\n')) {
  역전된텃밭.push(row.split(' '));
}

function solution(역전된텃밭) {
  const 높이 = 역전된텃밭.length;
  const 넓이 = 역전된텃밭[0].length;

  for (let i = 0; i < 높이; i++) {
    for (let j = 0; j < 넓이; j++) {
      역전된텃밭[i][j] = parseInt(역전된텃밭[i][j], 10);
      //아래서 해주는게 효율적이나 코드가복잡해지니까 일단 뻄
    }
  }

  let max = 0;
  let x = 0;
  let y = 0;

  for (let i = 1; i < 높이; i++) {
    for (let j = 1; j < 넓이; j++) {
      if (역전된텃밭[i][j] === 1) {
        let min;
        if (역전된텃밭[i - 1][j] >= 역전된텃밭[i][j - 1]) {
          min = 역전된텃밭[i][j - 1];
        } else if (역전된텃밭[i - 1][j] <= 역전된텃밭[i][j - 1]) {
          min = 역전된텃밭[i - 1][j];
        }
        if (min > 역전된텃밭[i - 1][j - 1]) {
          min = 역전된텃밭[i - 1][j - 1];
        }
        역전된텃밭[i][j] = min + 1;
        if (역전된텃밭[i][j] > max) {
          max = 역전된텃밭[i][j];
          x = i;
          y = j;
        }
      }
    }
  }
  console.log(`${max}X${max}`);

  for (let i = y - (max - 1); i < y + 1; i++) {
    for (let j = x - (max - 1); j < x + 1; j++) {
      역전된텃밭[i][j] = '#';
    }
  }

  return 역전된텃밭;
}

console.log(solution(역전된텃밭));
// 메모리제이션
// const N = 6;
// const memo = Array(N + 1).fill(0);

// function f(n) {
//   if (n === 1 || n === 2) {
//     memo[n] = 1;
//     return memo[n];
//   } else if (memo[n] !== 0) {
//     return memo[n];
//   } else {
//     memo[n] = f(n - 1) + f(n - 2);
//     return memo[n];
//   }
// }

// console.log(f(N));
// 0 1 1 2 3 5 8
// 피보나치 재귀
// else if 가 없다면 f(1) f(2)를 계속 반복해서 실행해서 비효율적
// 메모 배열에 담아서 반복호출하지않고 바로 전에 실행한 값 리턴
// 재귀는 위에서 아래로 풀이됨 업다운

//dp 다이나믹 프로그래밍
// 아래에서 위로 풀이됨

// let answer = [];
// aonswer[1] = 1;
// answer[2] = 1;

// for (let i = 3; i < 8; i++) {
//   answer = [i] = answer[i - 2] + answer[i - 1];
// }

// 재귀 : 중복의 가능성이 있으며, 탑다운 방식
// memorization : 탑다운 방식
// DP : 바텀업방식, 중복을 하지 않는다

// *************************************************************
// 문제97 : 택배 배달

// n 명의 택배 배달원은 쌓인 택배를 배달해야 합니다.
// 각 택배는 접수된 순서로 배달이 되며 택배마다 거리가 주어집니다.
// 거리1당 1의 시간이 걸린다고 가정하였을 때 모든 택배가 배달 완료될 시간을 구하세요.

// 1. 모든 택배의 배송 시간 1 이상이며 배달지에 도착하고 돌아오는 왕복 시간입니다.
// 2. 택배는 물류창고에서 출발합니다.
// 3. 배달을 완료하면 다시 물류창고로 돌아가 택배를 받습니다.
// 4. 물류창고로 돌아가 택배를 받으면 배달을 시작합니다.
// 5. 택배를 상차할 때 시간은 걸리지 않습니다.

// 입력은 배달원의 수와 택배를 배달하는 배달 시간이 주어집니다.

// ex) 배달원이 3명이고 각 거리가 [1,2,1,3,3,3]인 순서로 들어오는 경우

function 배달() {
  const 배달원 = 3;
  const 배달시간 = [1, 2, 1, 3, 3, 3];
  let 배달중 = Array(배달원).fill(0);

  let result = 0;

  while (배달시간.length) {
    for (let i = 0; i < 배달원; i++) {
      if (배달중[i] === 0) {
        배달중[i] += 배달시간.shift();
      }
    }
    배달중 = 배달중.map((x) => (x = x - 1));

    result += 1;
  }

  console.log(result + Math.max.apply(null, 배달중));
}

console.log(배달());
// 출력값 = 5
// *************************************************************
// 문제98 : 청길이의 패션 대회

// 패션의 선도주자 청길이는 패션의 발전을 위해 패션쇼를 방문해 유니크한 아이템을 조사하기로 하였습니다.
// 청길이는 입장하는 사람들의 패션에서 처음 보는 아이템 만을 기록합니다.
// 이때 청길이의 기록에서 아래 규칙에 맞게 배열로 출력해 주세요.

//     1. 청길이는 각 옷의 종류를 정수로 기록해 놓습니다.
//          ex) 입력은 "1번: 3,1 2번: 4 3번: 2,1,3 4번: 2,1,3,4" 형태의 문자열입니다.
//     2. 기록은 청길이가 번호 순서로 유니크한 옷의 번호를 적습니다.
//     3. 유니크한 옷은 기록된 순서로 추출되고 출력됩니다.
//          ex) 출력은 [3,1,4,2]입니다.

// 입출력예시

// 입력
// "1번: 4,2,3 2번: 3 3번: 2,3,4,1 4번: 2,3"

// 출력
// [4, 2, 3, 1]

// 입력
// "1번: 3,1 2번: 4 3번: 2,1,3 4번: 2,1,3,4"

// 출력
// [3, 1, 4, 2]

function unique(str) {
  const arr = str.split(/[0-9]번: /).slice(1);
  const result = [];

  for (let i of arr) {
    i.split(',').forEach((el) => {
      const int = parseInt(el);
      if (!result.includes(int)) {
        result.push(int);
      }
    });
  }

  return result;
}

console.log(unique('1번: 4,2,3 2번: 3 3번: 2,3,4,1 4번: 2,3'));
// *************************************************************
// 문제99 : 토끼들의 행진

// 토끼들이 징검다리를 건너려고 합니다. 하지만 돌이 부실해서 몇 번 건너지 못할 것 같습니다.
// 대기 중인 토끼들의 통과 여부를 배열에 담아 출력해 주세요.

// 1. 각 돌들이 얼마나 버틸 수 있는지 배열로 주어집니다.

// 2. 각 토끼가 착지할 때마다 돌의 내구도는 1씩 줄어듭니다.
//     ex) [1,2,1,4] 각 돌마다 1마리 2마리 1마리 4마리의 착지를 버틸 수 있습니다.

// 3. 토끼들은 점프력이 각자 다릅니다.
//     ex) [2,1] 첫 번째 토끼는 2칸씩, 두 번째 토끼는 1칸씩 점프합니다.

// 4. 각 토끼들은 순서대로 다리를 건넙니다.

// 입력
// 돌의내구도 = [1, 2, 1, 4]
// 토끼의점프력 = [2, 1]

// 출력
// ['pass', 'pass']

// 입력
// 돌의내구도 = [1, 2, 1, 4, 5, 2]
// 토끼의점프력 = [2, 1, 3, 1]

// 출력
// ['pass', 'pass', 'fail', 'fail']

function 토끼점프(내구도, 점프력) {
  const result = [];

  for (let i = 0; i < 점프력.length; i++) {
    let jump = 점프력[i] - 1;

    while (true) {
      if (내구도[jump]) {
        내구도[jump] -= 1;
      } else {
        result.push('fail');
        break;
      }

      jump += 점프력[i];

      if (jump >= 내구도.length) {
        result.push('pass');
        break;
      }
    }
  }

  return result;
}

console.log(토끼점프([1, 2, 1, 4, 5, 2], [2, 1, 3, 1]));
// *************************************************************
// 문제100 : 퍼즐게임

// N x M으로 이루어진 아래와 같은 공간에 퍼즐이 쌓여져 있습니다.

// 퍼즐을 맞추기 위해서는 반드시 맨 오른쪽 줄로 이동시켜 줘야 합니다.
// 만약 종류가 같은 퍼즐이 연속될 시에 점수가 추가되며 그 퍼즐은 사라집니다.

// 점수는 다음과 같습니다.
// - 파란색 공 : 1점
// - 빨간색 공 : 2점
// - 노란색 공 : 3점
// - 초록색 공 : 4점
// - 주황색 공 : 5점
// 점수는 공의 개수만큼 추가됩니다
// 예를 들어 빨간색 공이 2개 연속되어 없어졌을 경우 2*2 = 4점입니다.

// 게임 플레이어는 게임이 시작되면 어떤 퍼즐을 이동할 것인지 모두 작성합니다.
// 만약 비어있는 곳을 선택하게 된다면 점수가 1점 감소하며 그대로 진행합니다.
// 위 규칙에 맞는 점수를 리턴하는 함수를 작성하세요.

// 예를 들어 입력이 "1 1 1 1 3 3 3"일 경우,

// 입력
// 퍼즐판 = [[0,0,0,0],[0,1,0,3],[2,5,0,1],[2,4,4,1],[5,1,1,1]]
// 조작 = [1,1,1,1,3,3,3]

// 출력
// 2

function abc(plate, moves) {
  let stack = [0];
  let point = 0;
  console.log(moves, plate);

  while (moves.length !== 0) {
    let m = moves.shift();
    for (let i = 0; i < plate.length; i++) {
      if (plate[i][m - 1] !== 0) {
        if (stack[stack.length - 1] == plate[i][m - 1]) {
          point += plate[i][m - 1] * 2;
          plate[i][m - 1] = 0;
          stack.pop();
        } else {
          stack.push(plate[i][m - 1]);
        }
        plate[i][m - 1] = 0;
        break;
      } else {
        if (i == plate.length - 1 && plate[i][m - 1] == 0) {
          point -= 1;
        }
      }
    }
  }

  return point;
}

const plate = [
  [0, 0, 0, 0],
  [0, 1, 0, 3],
  [2, 5, 0, 1],
  [2, 4, 4, 1],
  [5, 1, 1, 1],
];
const moves = [1, 1, 1, 1, 3, 3, 3];

console.log(abc(plate, [1, 1, 1, 1, 3, 3, 3]));
// *************************************************************
